# SMART on FHIR Client Security Guide

This document details the security mechanisms implemented and recommended for the SMART on FHIR client library (`src/lib/client.ts`) and provides guidance for its secure deployment and usage.

## Overview of Authentication Flow

The client library implements the [SMART App Launch Framework](https://hl7.org/fhir/smart-app-launch/), specifically the OAuth 2.0 Authorization Code Grant flow with PKCE (Proof Key for Code Exchange). This flow is suitable for both traditional web applications and client-side applications (including those running in secure serverless environments like Cloudflare Workers) that cannot securely store a client secret.

The process involves two main functions:

1.  **`authorizeSmartClient(options)`**:
    *   Initiates the authentication process.
    *   Constructs an authorization URL pointing to the FHIR server's authorization endpoint.
    *   Generates a `code_verifier` (a cryptographically random string).
    *   Generates a `code_challenge` (SHA-256 hash of the `code_verifier`).
    *   Generates a `state` parameter (a random string for CSRF protection).
    *   The application must redirect the user's browser to this `authorizeUrl`.
    *   **Crucially, the calling application MUST securely store the `codeVerifier` and `stateValue`** (see "Secure Storage of `codeVerifier` and `stateValue`" below).

2.  **`createSmartFhirClient(options)`**:
    *   Handles the callback from the FHIR authorization server after the user authenticates and grants consent.
    *   Expects the authorization `code` (from the URL query parameters) and the previously stored `codeVerifier` and `expectedState` (which is the `stateValue` generated by `authorizeSmartClient`).
    *   Verifies that the `state` parameter received in the callback matches the `expectedState` to prevent Cross-Site Request Forgery (CSRF) attacks.
    *   Uses the `fhirclient` library's `FHIR.oauth2.ready()` method to:
        *   Exchange the authorization `code` for an access token at the FHIR server's token endpoint.
        *   Send the `code_verifier` to the token endpoint. The server verifies it against the `code_challenge` sent earlier, ensuring the request comes from the same client that initiated the flow (PKCE).
    *   If successful, returns the `access_token`.

## Key Security Mechanisms Implemented

*   **OAuth 2.0 Authorization Code Grant with PKCE**:
    *   Ensures that even if the authorization code is intercepted, it cannot be exchanged for an access token without the `code_verifier`. This is critical for public clients.
    *   The `code_challenge_method` used is `S256`.
*   **State Parameter for CSRF Protection**:
    *   A unique `state` value is generated for each authorization request and validated upon callback.
*   **HTTPS Enforcement**:
    *   The library includes checks to ensure that the FHIR server's Issuer URL (`iss`), the `redirectUri`, and the discovered `authorization_endpoint` are all using `https://`. Warnings or errors are thrown if non-HTTPS URLs are detected for these critical endpoints.
    *   **All communication with the FHIR server and identity provider MUST be over HTTPS.**
*   **Well-Known SMART Configuration**:
    *   The client fetches the authorization server's metadata (including the authorization endpoint) from the `iss` + `/.well-known/smart-configuration` endpoint, adhering to the SMART standard.

## Critical Security Responsibilities of the Calling Application

While the client library provides core security features, its overall security relies heavily on how it is integrated and used. The calling application has the following critical responsibilities:

### 1. Secure Storage of `codeVerifier` and `stateValue`

Between the call to `authorizeSmartClient` and `createSmartFhirClient`, the `codeVerifier` and `stateValue` must be stored securely.

*   **Recommended Method (Web Applications / Workers acting for a browser session): HttpOnly, Secure, SameSite Cookies**
    *   **HttpOnly**: Prevents access from client-side JavaScript, mitigating XSS risks.
    *   **Secure**: Ensures the cookie is only sent over HTTPS.
    *   **SameSite**: (`Strict` or `Lax`) Provides CSRF protection. `Strict` is more secure but `Lax` might be needed if the authorization server callback involves a cross-site redirect.
    *   **Path**: Set an appropriate path for the cookie (e.g., the path of your callback endpoint).
    *   **Expiration**: The cookie should have a short expiration, ideally matching the expected time to complete the OAuth flow (e.g., 5-10 minutes).

    Example (Conceptual - actual implementation depends on your server/worker environment):
    ```javascript
    // After calling authorizeSmartClient:
    // setCookie('pkce_code_verifier', codeVerifier, { httpOnly: true, secure: true, sameSite: 'Lax', path: '/your/callback/path', maxAge: 600 });
    // setCookie('oauth_state', stateValue, { httpOnly: true, secure: true, sameSite: 'Lax', path: '/your/callback/path', maxAge: 600 });

    // In your callback handler, before calling createSmartFhirClient:
    // const pkceCodeVerifier = getCookie('pkce_code_verifier');
    // const expectedState = getCookie('oauth_state');
    ```

*   **Alternative (Server-Side Sessions)**: If your application uses server-side sessions, these values can be stored in the session data. Ensure your session management is secure (e.g., strong session IDs, secure cookie flags for session cookies).

*   **DO NOT store `codeVerifier` or `stateValue` in `localStorage`, `sessionStorage`, or non-HttpOnly cookies.** This makes them vulnerable to XSS attacks.

### 2. Secure Handling and Storage of Access Tokens

The `createSmartFhirClient` function returns an `access_token`.

*   **Storage**:
    *   **If the token needs to be used by client-side JavaScript (e.g., in a Single Page Application):** This is generally discouraged if it can be avoided. If necessary, be aware of XSS risks. Storing it in JavaScript memory is safer than `localStorage`.
    *   **If the token is used by your server-side backend (e.g., a Cloudflare Worker making FHIR API calls on behalf of the user):** This is a more secure pattern.
        *   The worker can receive the token and store it associated with the user's session (e.g., in an HttpOnly, Secure cookie, or an encrypted server-side session store if long-term access is needed via refresh tokens).
        *   For immediate use, the token can be held in memory for the duration of the request processing.
*   **Transmission**: Always transmit access tokens over HTTPS. Include them in the `Authorization` header as a Bearer token: `Authorization: Bearer <access_token>`.
*   **Lifetime**: Access tokens are typically short-lived. Your application should be prepared to handle token expiration, often by re-initiating the authorization flow or using a refresh token.

### 3. Refresh Token Strategy (If Applicable)

This client library currently focuses on the initial acquisition of an access token.

*   If your application requires access to FHIR resources for longer than the lifetime of a single access token without user re-authentication, you will need to request the `offline_access` scope (if supported by the server) to obtain a refresh token.
*   **Refresh tokens are extremely sensitive.**
    *   They MUST be stored securely, typically encrypted at rest in a server-side database or secure store.
    *   They should only be accessible to the component responsible for exchanging them for new access tokens (e.g., your backend server/worker).
    *   `fhirclient.js` can manage the refresh process if initialized appropriately with a refresh token.

### 4. Exact `redirect_uri` Pre-registration

*   The `redirect_uri` used in `authorizeSmartClient` (and configured via `SMART_REDIRECT_URI` or options) **MUST** be pre-registered *exactly* as it is with the FHIR authorization server. Any mismatch will cause the flow to fail.
*   The library ensures that the `redirect_uri` used during the token exchange in `createSmartFhirClient` matches the URI where the code was delivered.

### 5. Configuration and Environment Variables

*   **`SMART_CLIENT_ID`**: The public client ID for your application.
*   **`SMART_SCOPE`**: The OAuth scopes your application requires (e.g., `patient/*.read launch openid fhirUser`).
*   **`SMART_ISS`**: The full URL of the FHIR server (Issuer). Must be HTTPS.
*   **`SMART_REDIRECT_URI`**: The full callback URL for your application. Must be HTTPS and pre-registered.
*   **`SMART_LAUNCH_TOKEN` (Optional)**: Used for EHR launch scenarios.

Securely manage these settings, especially if deploying to a serverless environment. Use platform-provided secret management tools (e.g., Cloudflare Worker secrets). Do not hardcode sensitive information directly in the source code if it can be avoided.

## Other Security Considerations

*   **Input Validation**: While the library performs some checks, ensure any inputs passed to these functions from external sources are validated.
*   **Content Security Policy (CSP)**: If your application has a frontend, implement a strong CSP to mitigate XSS and other injection attacks.
*   **Regular Dependency Updates**: Keep `fhirclient.js` and other dependencies updated to their latest secure versions.
*   **Logging**: The library logs some errors. Ensure your application has robust logging for security events and errors, but be careful not to log sensitive data like access tokens or `codeVerifier`.
*   **Token Revocation**: For a complete solution, implement token revocation when a user logs out or if a token is suspected to be compromised. This typically involves calling the FHIR server's token revocation endpoint. `fhirclient.js` may offer utilities for this.

By understanding these mechanisms and adhering to the responsibilities outlined, you can build a secure SMART on FHIR application.
---

This initial draft covers the core aspects. I will now review and refine it.```
